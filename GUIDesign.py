# Form implementation generated from reading ui file 'GUI.ui'
#
# Created by: PyQt6 UI code generator 6.1.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

#Needed imports for applications
import hashlib
import time
import os
import multiprocessing
from multiprocessing import Process, Event
import random
import subprocess

#PyQt6 imports
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtWidgets import QFileDialog, QApplication, QWidget
from PyQt6.QtCore import QObject, QRunnable, QThread, pyqtSignal, Qt, QThreadPool

#Attack algorithm imports
from GUIOptions import Ui_OptionsWindow
from GUIHelp import Ui_AlgorithmDocs

from AttackOptions import AttackOptions
from AttackAlgorithms.BruteForceAttackAlgorithm import BruteForceAttackAlgorithm 
from AttackAlgorithms.DictionaryAttackAlgorithm import DicionaryAttackAlgorithm
from AttackAlgorithms.HybridAttackAlgorithm import HybridAttackAlgorithm
from AttackAlgorithms.RulebasedAttackAlgorithm import RulebasedAttackAlgorithm
from AttackAlgorithms.MarkovAttackAlgorithm import MarkovAttackAlgorithm

"""
Class Name: BruteForceWorker
Description: Will start brute force attack using core_count to start multi-process
Parameters: QRunnable: Implements a runnable interface
"""
class BruteForceWorker(QRunnable):
    """"
    Name: __init__
    Description: Constructor function for BruteForceWorker. 
    Parameters: self, attack_options: AttackOptions, charset:String, output:QTextBrowser
    returns: none
    """
    def __init__(self, attack_options, charset, output):
        super().__init__()
        self.attack_options = attack_options
        self.charset = charset
        self.output = output
        
        self.process_list = list()
        self.core_count = self.attack_options.core_count

    """"
    Name: split_data
    Description: Splits a chracter set into equal chunck  
    Parameters: self 
    returns: none
    """
    def split_data(self):
        #define data
        split_data = list()
        self.charset = list(self.charset)
        charset_len = len(self.charset)
        gap = int(charset_len / self.attack_options.core_count)

        #split data based on a gap size 
        data = [self.charset[i:i+gap] for i in range(0, charset_len, gap)]
        #if the split data size does not match the core_count then it will randomly allocate a character to another array
        if(len(data) != self.core_count):
            reallocate_array = data[-1]
            for idx, x in enumerate(reallocate_array):
                random_int = random.randint(0,self.core_count)
                data[random_int] += x
            data.pop(-1)
            
        return data

    """
    Name: process_result
    Description: Will get the correct result file and output result to output box
    Parameters: self 
    returns: none
    """
    def process_result(self):
        result_counter = 1 
        #Will cound number of results file in case there are more than one result file
        for filename in os.listdir("AppData/"):
            if filename.startswith("result"):
                result_counter += 1

        #Will get the latest version of the results from AppData folder
        if(result_counter == 0):
            filename = f"AppData/result.txt"
        else:
            result_counter -= 1 
            if(result_counter == 0):
                filename = f"AppData/result.txt"
            else:
                filename = f"AppData/result{result_counter}.txt"

        #Will open the results file and output results in the correct order
        with open(filename, "r") as result:
            for idx, data in enumerate(result): 
                if(idx == 1):
                    self.output.append(f"\t{data} sec")
                else:
                    self.output.append(f"\tPassword found: {data}")
    
    """
    Name: brute_force_cpu
    Description: Will start a brute force attack using the CPU
    Parameters: self 
    returns: none
    """
    def brute_force_cpu(self):
        #data with starting points
        data = self.split_data()
        
        #found event triggered when password found
        self.found = Event()
        #creates processes passing in needed data
        for idx ,i in enumerate(range(self.core_count)):
            starting_point = data[i][0]
            dictionary = BruteForceAttackAlgorithm(self.attack_options, starting_point, self.charset ,self.found)

            #Creating process using the dictionary main function
            p = multiprocessing.Process(target=dictionary.main)
            self.output.append(f"\t-= Starting process {i} =-")
            self.process_list.append(p)

        #Starts processes
        for process in self.process_list:
            process.start()

        #Wait's until password is found
        self.found.wait()

        #Terminates processes
        for process in self.process_list:
            print("\t-= Terminating =-")
            process.terminate()

        #Waits for processes to finish terminating
        for process in self.process_list:
            process.join()
            
        #Finishing up
        self.process_result()
        self.output.append("\t-= Attack Finished =- ")
        self.process_list.clear()
        print("Done")
    
    """
    Name: stop_process
    Description: Will terminate processes when button is pressed
    Parameters: self 
    returns: none
    """
    def stop_process(self):
        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            self.output.append(f"\t-= Terminating {process} =-")
            process.terminate()
    
    """
    Name: run
    Description: Starts brute force attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        #if there is no has file then run single hash crack
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting Brute Force Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.brute_force_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting Brute Force Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.brute_force_cpu()



"""
Class Name: DictionaryWorker
Description: Will start dictionary attack using core_count to start multi-process
Parameters: QRunnable: Implements a runnable interface
"""
class DictionaryWorker(QRunnable):
    
    """"
    Name: __init__
    Description: Constructor function Dictionary Worker. 
    Parameters: self, attack_options: AttackOptions, output:QTextBrowser
    returns: none
    """
    def __init__(self, attack_options, output):
        super().__init__()
        self.attack_options = attack_options
        self.output = output

        self.process_list = list()
        self.core_count = self.attack_options.core_count

    """"
    Name: split_data
    Description: Splits a wordlist into equal sections for processing  
    Parameters: self 
    returns: none
    """
    def split_data(self):
        data_to_split = list()
        tic = time.time()

        with open(self.attack_options.wordlist_location, encoding="latin-1") as file:
            data_to_split = [line for line in file]

        data = [data_to_split[i::self.core_count] for i in range(self.core_count)] #split up data into chuncks for each process
        toc = time.time()
        
        print('Split Data: {:.4f} seconds'.format(toc-tic))
        self.output.append('\tSplit Data: {:.4f} seconds'.format(toc-tic))
        
        return data
    
    """
    Name: process_result
    Description: Will get the correct result file and output result to output box
    Parameters: self 
    returns: none
    """
    def process_result(self):
        result_counter = 1 
        #Will cound number of results file in case there are more than one result file
        for filename in os.listdir("AppData/"):
            if filename.startswith("result"):
                result_counter += 1

        #Will get the latest version of the results from AppData folder
        if(result_counter == 0):
            filename = f"AppData/result.txt"
        else:
            result_counter -= 1 
            if(result_counter == 0):
                filename = f"AppData/result.txt"
            else:
                filename = f"AppData/result{result_counter}.txt"

        #Will open the results file and output results in the correct order
        with open(filename, "r") as result:
            for idx, data in enumerate(result):
                if(idx == 1):
                    self.output.append(f"\t{data} sec")
                else:
                    self.output.append(f"\tPassword: {data}")

    """
    Name: dictionary_cpu
    Description: Will start a dictionary attack using the CPU
    Parameters: self 
    returns: none
    """
    def dictionary_cpu(self):
        #Split data into chunk for each process
        data = self.split_data()
        #found event triggered when password found
        self.found = Event()

        #creates processes passing in needed data
        for idx, i in enumerate(range(self.core_count)):
            dictionary = DicionaryAttackAlgorithm(self.attack_options, data[idx], self.found)
            #Creating process using the dictionary main function
            p = multiprocessing.Process(target=dictionary.main)
            self.output.append(f"\t-= Starting process {i} =-")
            self.process_list.append(p)

        #get pids of process
        self.pid = [process.pid for process in self.process_list]

        #Starts processes
        for process in self.process_list:
            process.start()
            
        #Wait's until password is found
        self.found.wait()
    
        #When event is triggered, terminate all processes
        for process in self.process_list:
            print("-= Terminating =-")
            process.terminate()

        #Waits until all processes are finished terminating
        for process in self.process_list:
            process.join()
            
        self.process_result()
        self.output.append("\tAttack Finished ")
        print("Done")

    """
    Name: stop_process
    Description: Will terminate processes when button is pressed
    Parameters: self 
    returns: none
    """
    def stop_process(self):
        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            self.output.append(f"\t-= Terminating {process} =-")
            process.terminate()

    """
    Name: pause_process
    Description: Will pause an on going process
    Parameters: self 
    returns: none
    """
    # def pause_process(self):
    #     print("Pauseing Application")
    #     for id in self.pid:
    #         p = psutil.Process(id)
    #         p.suspend()
        
    """
    Name: resume_process
    Description: Will resume an on going process
    Parameters: self 
    returns: none
    """
    # def resume_process(self):
    #     print("Resuming Application")
    #     for id in self.pid:
    #         p = psutil.Process(id)
    #         p.resume()
       
    """
    Name: run
    Description: Starts dictionary attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        #if there is no has file then run single hash crack
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting Dictionary Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.dictionary_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting Dictionary Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.dictionary_cpu() 

"""
Class Name: HybridWorker
Description: Will start hybrid attack using core_count to multi-process
Parameters: QRunnable: Start create a thread class
"""
class HybridWorker(QRunnable):
    """"
    Name: __init__
    Description: Constructor function Dictionary Worker. 
    Parameters: self, attack_options: AttackOptions, output: QTextBrowser
    returns: none
    """
    def __init__(self, attack_options, output):
        super().__init__()
        self.attack_options = attack_options
        self.output = output

        self.process_list = list()
        self.core_count = self.attack_options.core_count
        self.HYBRID_RULE_DIR = "Rulesets/hybrid_rule/"

        
    """"
    Name: split_data
    Description: Splits a dictionary into equal sections for processing  
    Parameters: self 
    returns: none
    """
    def split_data(self):
        data_to_split = list()
        start = time.time()
        #append data using set comprehensions
        with open(self.attack_options.wordlist_location, encoding="latin-1") as file: 
            data_to_split = [line for line in file]
        
        data = [data_to_split[i::self.core_count] for i in range(self.core_count)] #split up data into chuncks for each process
        end = time.time()

        print('Split Data: {:.4f} seconds'.format(end-start))
        self.output.append('\tSplit Data: {:.4f} seconds'.format(end-start))
        
        return data

    """"
    Name: get_rules
    Description: Splits a rule file in equal chunks   
    Parameters: self 
    returns: none
    """
    def get_rules(self):
        rules_to_split = list()
        start = time.time()
        #opens hybrid rule file
        with open("Rulesets\hybrid_rule\hybrid-0-4.rule","r") as file:
            rules_to_split = [line for line in file]

        rules =  [rules_to_split[i::self.core_count] for i in range(self.core_count)]
        end = time.time()

        print('Split rules: {:.4f} seconds'.format(end-start))
        self.output.append('\tSplit rules: {:.4f} seconds'.format(end-start))

        return rules
    
    """
    Name: process_result
    Description: Will get the correct result file and output result to output box
    Parameters: self 
    returns: none
    """
    def process_result(self):
        result_counter = 1 
        #Will cound number of results file in case there are more than one result file
        for filename in os.listdir("AppData/"):
            if filename.startswith("result"):
                result_counter += 1

        #Will get the latest version of the results from AppData folder
        if(result_counter == 0):
            filename = f"AppData/result.txt"
        else:
            result_counter -= 1 
            if(result_counter == 0):
                filename = f"AppData/result.txt"
            else:
                filename = f"AppData/result{result_counter}.txt"

        #Will open the results file and output results in the correct order
        with open(filename, "r") as result:
            for idx, data in enumerate(result):
                data = data.rstrip("\n")
                if(idx == 1):
                    self.output.append(f"\t{data} sec")
                else:
                    self.output.append(f"\tPassword: {data}")
    
    """
    Name: hybrid_cpu
    Description: Will start a hybrid attack using the CPU
    Parameters: self 
    returns: none
    """
    def hybrid_cpu(self):
        #Split data into chunk for each process
        data = self.split_data()
        #process rule file
        rules = self.get_rules()
        #found event triggered when password found
        self.found = Event()

        for idx, t in enumerate(range(self.core_count)):
            dictionary = HybridAttackAlgorithm(self.attack_options, data[idx], rules[idx], self.found)
            #Creating process using the dictionary main function
            p = multiprocessing.Process(target=dictionary.main)
            self.process_list.append(p)

        #Starts processes
        for process in self.process_list:
            process.start()
            
        #Wait's until password is found
        self.found.wait()

        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            process.terminate()

        for process in self.process_list:
            process.join()
            
        self.process_result()
        self.output.append("\tAttack Finished ")
        print("Done")

    """
    Name: stop_process
    Description: Will terminate processes when button is pressed
    Parameters: self 
    returns: none
    """
    def stop_process(self):
        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            self.output.append(f"\t-= Terminating {process} =-")
            process.terminate()

    """
    Name: run
    Description: Starts hybrid attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        #if there is no has file then run single hash crack
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting Hybrid Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.hybrid_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting Hybrid Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.hybrid_cpu() 

"""
Class Name: RuleBasedWorker
Description: Will start a rule based attack using core_count to multi-process
Parameters: QRunnable: Start create a thread class
"""
class RuleBasedWorker(QRunnable):

    """"
    Name: __init__
    Description: Constructor function RuleBased Worker. 
    Parameters: self, attack_options: AttackOptions, output: QTextBrowser
    returns: none
    """
    def __init__(self, attack_options, output,):
        super().__init__()
        self.attack_options = attack_options
        self.output = output
        self.process_list = list()
        self.core_count = self.attack_options.core_count

        self.RULE_PATH = 'Rulesets\\rule_based_rules'
        
    """"
    Name: split_data
    Description: Splits a dictionary into equal sections for processing  
    Parameters: self 
    returns: none
    """
    def split_data(self):
        data_to_split = list()
        start = time.time()
        #append data using set comprehensions
        with open(self.attack_options.wordlist_location, encoding="latin-1") as file: 
            data_to_split = [line for line in file]
        
        data = [data_to_split[i::self.core_count] for i in range(self.core_count)] #split up data into chuncks for each process
        end = time.time()

        #Print timing for split data
        print('Split Data: {:.4f} seconds'.format(end-start))
        self.output.append('\tSplit Data: {:.4f} seconds'.format(end-start))
        
        return data

    """
    Name: get_rules
    Description: Will get all rules from 
    Parameters: self 
    returns: none
    """
    def get_rules(self):
        rules = list()
        start = time.time()
        #opens rule files
        for filename in os.listdir(self.RULE_PATH):
            if(filename.endswith('.rule')):
                with open(os.path.join(self.RULE_PATH, filename)) as file:
                    rules += [data.rstrip() for data in file]

        end = time.time()

        #print timing data
        print('Split rules: {:.4f} seconds'.format(end-start))
        self.output.append('\tSplit rules: {:.4f} seconds'.format(end-start))

        return rules

    """
    Name: process_result
    Description: Will get the correct result file and output result to output box
    Parameters: self 
    returns: none
    """
    def process_result(self):
        result_counter = 1 
        #Will cound number of results file in case there are more than one result file
        for filename in os.listdir("AppData/"):
            if filename.startswith("result"):
                result_counter += 1

        #Will get the latest version of the results from AppData folder
        if(result_counter == 0):
            filename = f"AppData/result.txt"
        else:
            result_counter -= 1 
            if(result_counter == 0):
                filename = f"AppData/result.txt"
            else:
                filename = f"AppData/result{result_counter}.txt"

        #Will open the results file and output results in the correct order
        with open(filename, "r") as result:
            for idx, data in enumerate(result):
                data = data.rstrip("\n")
                if(idx == 1):
                    self.output.append(f"\t{data} sec")
                else:
                    self.output.append(f"\tPassword: {data}")

    """
    Name: rulebase_cpu
    Description: Will start a rulebased attack using the CPU
    Parameters: self 
    returns: none
    """
    def rulebase_cpu(self):
        #Split data into chunk for each process
        data = self.split_data()
        #process rule file
        rules = self.get_rules()
        #found event triggered when password found
        self.found = Event()

        for idx, i in enumerate(range(self.core_count)):
            dictionary = RulebasedAttackAlgorithm(self.attack_options, data[idx], rules, self.found)
            #Creating process using the dictionary main function
            p = multiprocessing.Process(target=dictionary.main)
            self.process_list.append(p)

        #Starts processes
        for process in self.process_list:
            process.start()
            
        #Wait's until password is found
        self.found.wait()

        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            process.terminate()

        for process in self.process_list:
            process.join()
            
        self.process_result()
        self.output.append(" Attack Finished ")
        print("Done")

    """
    Name: stop_process
    Description: Will terminate processes when button is pressed
    Parameters: self 
    returns: none
    """
    def stop_process(self):
        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            self.output.append(f"\t-= Terminating {process} =-")

            process.terminate()

    """
    Name: run
    Description: Starts rule based attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting Rule-Based Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.rulebase_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting Hybrid Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.rulebase_cpu() 

"""
Class Name: RainbowTableWorker
Description: Will start rainbow table attack using core_count to multi-process
Parameters: QRunnable: Start create a thread class
"""
class RainbowTableAttack(QRunnable):
    def __init__(self, attack_options, output):
        self.attack_options = attack_options
        self.output = output;
        self.filename = "C:\\Users\\ethan\\OneDrive\\Desktop\\Year3\\DSP\\Password_Cracker_App\\Rainbowcrack\\start.bat"
        self.bat = None

    """
    Name: add_hash_to_bat
    Description: Will add the input hash value to the bat file 
    Parameters: self
    returns: none
    """
    def add_hash_to_bat(self):
        with open(self.filename, "r") as file:
            self.bat = file.read()

        self.bat= self.bat.replace("HASH", self.attack_options.hash_value)

        with open(self.filename, "w") as file:
            file.write(self.bat)            
    
    """
    Name: remove_hash_from_bat
    Description: Will add the HASH keyword back to the bat file for future attacks
    Parameters: self
    returns: none
    """
    def remove_hash_from_bat(self):
        with open(self.filename, "r") as file:
            self.bat = file.read()

        self.bat = self.bat.replace(self.attack_options.hash_value, "HASH")

        with open(self.filename, "w") as file:
            file.write(self.bat)           
    
    """
    Name: rainbowtable_cpu
    Description: Will start the rainbow table attack using RainbowCrack through a bat file
    Parameters: self
    returns: none
    """
    def rainbowtable_cpu(self):
        #Add hash value to bat file
        self.add_hash_to_bat()
        #Start attack from a bat file
        p = subprocess.Popen(self.filename, stdout=subprocess.PIPE, shell=True)
        p.wait()
        result = p.stdout.read()
        #remove hash value from bat file
        self.remove_hash_from_bat()
        #process output of command prompt
        self.output.append(result.decode())
        self.output.append("\t-= Rainbow Crack output =-")

    """
    Name: stop_process
    Description: Will terminate processes when button is pressed
    Parameters: self 
    returns: none
    """
    def stop_process(self):
        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            self.output.append(f"\t-= Terminating {process} =-")

            process.terminate()

    """
    Name: run
    Description: Starts rainbow table attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting RainbowTable Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.rainbowtable_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting RainbowTable Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.rainbowtable_cpu() 
    
"""
Class Name: MarkovWorker
Description: Will start markov chain attack using core_count to multi-process
Parameters: QRunnable: Start create a thread class
"""
class MarkovWorker(QRunnable):
    def __init__(self, attack_options, output):
        self.attack_options = attack_options
        self.output = output


    def markov_cpu(self):
        #found event triggered when password found
        self.found = Event()

        for idx, i in enumerate(range(self.core_count)):
            dictionary = MarkovAttackAlgorithm(self.attack_options, data[idx], self.found)
            #Creating process using the dictionary main function
            p = multiprocessing.Process(target=dictionary.main)
            self.process_list.append(p)

        #Starts processes
        for process in self.process_list:
            process.start()
            
        #Wait's until password is found
        self.found.wait()

        #Terminates processes
        for process in self.process_list:
            print("Terminating")
            process.terminate()

        for process in self.process_list:
            process.join()
            
        self.process_result()
        self.output.append(" Attack Finished ")
        print("Done")

    """
    Name: run
    Description: Starts markov chain attack selecting the CPU and check for a hash_file
    Parameters: self 
    returns: none
    """
    def run(self):
        hash_file = list()
        if(self.attack_options.hash_file_location == ""):
            self.output.append("\t-= Starting Markov Chains Attack =-")
            if(self.attack_options.cpu):
                self.output.append("\tUsing CPU")
                self.markov_cpu()
        else:
            with open(self.attack_options.hash_file_location) as file:
                hash_file = [line.strip() for line in file]

            for hash in hash_file:
                self.attack_options.hash_value = hash
                self.output.append("\t-= Starting Markov Chains Attack =-")
                if(self.attack_options.cpu):
                    self.output.append("\tUsing CPU")
                    self.markov_cpu() 

"""
Class Name: Ui_App
Class Description: Main window for application
Parameters: None
"""
class Ui_App(object):
    """"
    Name: __init__
    Description: Constructor function Ui_app Worker used to initialize data. 
    Parameters: self 
    returns: none
    """
    def __init__(self):
        super().__init__()    
        #Object Initialization 
        attack_options = AttackOptions("attack1")
        self.options = Ui_OptionsWindow(attack_options)
        #Combo box Initialization
        self.hash_type_content = hashlib.algorithms_guaranteed
        self.attack_type_content = ["Brute Force", "Dictionary", "Hybrid", "Rule-Based", "Rainbow Table", "Markov Chain"]
        #Attack option Initialization
        self.lower_alpha = "abcdefghijklmnopqrstuvwxyz"
        self.upper_alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        self.numeric = "1234567890"
        self.symbols = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ '
        self.all_charset = self.lower_alpha + self.upper_alpha + self.numeric + self.symbols
        self.hash_file_location = ""

    """"
    Name: setupUi
    Description: Will initialize all UI elements and displays application to user
    Parameters: App:QMainWindows 
    returns: none
    """
    def setupUi(self, App):
        App.setObjectName("App")
        App.resize(1012, 696)
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        App.setPalette(palette)
        self.centralwidget = QtWidgets.QWidget(App)
        self.centralwidget.setObjectName("centralwidget")
        self.attackGroup = QtWidgets.QGroupBox(self.centralwidget)
        self.attackGroup.setGeometry(QtCore.QRect(20, 10, 991, 561))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.attackGroup.setPalette(palette)
        font = QtGui.QFont()
        font.setPointSize(16)
        self.attackGroup.setFont(font)
        self.attackGroup.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.attackGroup.setObjectName("attackGroup")
        self.hashValueLbl = QtWidgets.QLabel(self.attackGroup)
        self.hashValueLbl.setGeometry(QtCore.QRect(10, 30, 61, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(False)
        self.hashValueLbl.setFont(font)
        self.hashValueLbl.setObjectName("hashValueLbl")
        self.hashInputTxt = QtWidgets.QTextEdit(self.attackGroup)
        self.hashInputTxt.setGeometry(QtCore.QRect(70, 30, 811, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.hashInputTxt.setFont(font)
        self.hashInputTxt.setObjectName("hashInputTxt")
        self.crackBtn = QtWidgets.QPushButton(self.attackGroup)
        self.crackBtn.setGeometry(QtCore.QRect(10, 360, 101, 31))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.crackBtn.setFont(font)
        self.crackBtn.setObjectName("crackBtn")
        self.deviceFrame = QtWidgets.QFrame(self.attackGroup)
        self.deviceFrame.setGeometry(QtCore.QRect(10, 270, 101, 81))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.deviceFrame.setPalette(palette)
        self.deviceFrame.setTabletTracking(False)
        self.deviceFrame.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.deviceFrame.setAutoFillBackground(True)
        self.deviceFrame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.deviceFrame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.deviceFrame.setObjectName("deviceFrame")
        self.deviceLbl = QtWidgets.QLabel(self.deviceFrame)
        self.deviceLbl.setGeometry(QtCore.QRect(20, 10, 91, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.deviceLbl.setFont(font)
        self.deviceLbl.setObjectName("deviceLbl")
        self.cpu_enabled = QtWidgets.QRadioButton(self.deviceFrame)
        self.cpu_enabled.setGeometry(QtCore.QRect(20, 40, 71, 20))
        self.cpu_enabled.setObjectName("cpu_enabled")
        self.charsetFrame = QtWidgets.QFrame(self.attackGroup)
        self.charsetFrame.setGeometry(QtCore.QRect(770, 70, 211, 151))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.charsetFrame.setPalette(palette)
        self.charsetFrame.setTabletTracking(False)
        self.charsetFrame.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.charsetFrame.setAutoFillBackground(True)
        self.charsetFrame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.charsetFrame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.charsetFrame.setObjectName("charsetFrame")
        self.charsetLbl = QtWidgets.QLabel(self.charsetFrame)
        self.charsetLbl.setGeometry(QtCore.QRect(10, 10, 101, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.charsetLbl.setFont(font)
        self.charsetLbl.setObjectName("charsetLbl")
        self.charsetAll = QtWidgets.QCheckBox(self.charsetFrame)
        self.charsetAll.setGeometry(QtCore.QRect(10, 40, 161, 20))
        self.charsetAll.setObjectName("charsetAll")
        self.charsetLower = QtWidgets.QCheckBox(self.charsetFrame)
        self.charsetLower.setGeometry(QtCore.QRect(10, 60, 181, 21))
        self.charsetLower.setObjectName("charsetLower")
        self.charsetUpper = QtWidgets.QCheckBox(self.charsetFrame)
        self.charsetUpper.setGeometry(QtCore.QRect(10, 80, 181, 20))
        self.charsetUpper.setObjectName("charsetUpper")
        self.charsetNumbers = QtWidgets.QCheckBox(self.charsetFrame)
        self.charsetNumbers.setGeometry(QtCore.QRect(10, 100, 151, 21))
        self.charsetNumbers.setObjectName("charsetNumbers")
        self.charsetSymbols = QtWidgets.QCheckBox(self.charsetFrame)
        self.charsetSymbols.setGeometry(QtCore.QRect(10, 120, 151, 21))
        self.charsetSymbols.setObjectName("charsetSymbols")
        self.wordlistFrame = QtWidgets.QFrame(self.attackGroup)
        self.wordlistFrame.setEnabled(True)
        self.wordlistFrame.setGeometry(QtCore.QRect(390, 70, 371, 151))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.wordlistFrame.setPalette(palette)
        self.wordlistFrame.setTabletTracking(False)
        self.wordlistFrame.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.wordlistFrame.setAutoFillBackground(True)
        self.wordlistFrame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.wordlistFrame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.wordlistFrame.setObjectName("wordlistFrame")
        self.wordlistLbl = QtWidgets.QLabel(self.wordlistFrame)
        self.wordlistLbl.setGeometry(QtCore.QRect(10, 10, 191, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.wordlistLbl.setFont(font)
        self.wordlistLbl.setObjectName("wordlistLbl")
        self.wordlistTxt = QtWidgets.QPlainTextEdit(self.wordlistFrame)
        self.wordlistTxt.setGeometry(QtCore.QRect(10, 40, 351, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.wordlistTxt.setFont(font)
        self.wordlistTxt.setObjectName("wordlistTxt")
        self.browseBtn = QtWidgets.QPushButton(self.wordlistFrame)
        self.browseBtn.setGeometry(QtCore.QRect(10, 80, 111, 31))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.browseBtn.setFont(font)
        self.browseBtn.setObjectName("browseBtn")
        self.wordlistFilenameLbl = QtWidgets.QLabel(self.wordlistFrame)
        self.wordlistFilenameLbl.setGeometry(QtCore.QRect(10, 120, 351, 31))
        self.wordlistFilenameLbl.setObjectName("wordlistFilenameLbl")
        self.attacktypeFrame = QtWidgets.QFrame(self.attackGroup)
        self.attacktypeFrame.setGeometry(QtCore.QRect(200, 70, 181, 151))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.attacktypeFrame.setPalette(palette)
        self.attacktypeFrame.setTabletTracking(False)
        self.attacktypeFrame.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.attacktypeFrame.setAutoFillBackground(True)
        self.attacktypeFrame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.attacktypeFrame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.attacktypeFrame.setObjectName("attacktypeFrame")
        self.attackTypeLbl = QtWidgets.QLabel(self.attacktypeFrame)
        self.attackTypeLbl.setGeometry(QtCore.QRect(30, 10, 111, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.attackTypeLbl.setFont(font)
        self.attackTypeLbl.setObjectName("attackTypeLbl")
        self.attackTypeCombo = QtWidgets.QComboBox(self.attacktypeFrame)
        self.attackTypeCombo.setGeometry(QtCore.QRect(10, 40, 161, 31))
        self.attackTypeCombo.setObjectName("attackTypeCombo")
        self.attackOptionsBtn = QtWidgets.QPushButton(self.attacktypeFrame)
        self.attackOptionsBtn.setGeometry(QtCore.QRect(10, 100, 161, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.attackOptionsBtn.setFont(font)
        self.attackOptionsBtn.setObjectName("attackOptionsBtn")
        self.hashTypeFrame = QtWidgets.QFrame(self.attackGroup)
        self.hashTypeFrame.setGeometry(QtCore.QRect(10, 70, 181, 151))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.hashTypeFrame.setPalette(palette)
        self.hashTypeFrame.setTabletTracking(False)
        self.hashTypeFrame.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.hashTypeFrame.setAutoFillBackground(True)
        self.hashTypeFrame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.hashTypeFrame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.hashTypeFrame.setObjectName("hashTypeFrame")
        self.hashTypeLbl = QtWidgets.QLabel(self.hashTypeFrame)
        self.hashTypeLbl.setGeometry(QtCore.QRect(40, 10, 101, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.hashTypeLbl.setFont(font)
        self.hashTypeLbl.setObjectName("hashTypeLbl")
        self.hashTypeCombo = QtWidgets.QComboBox(self.hashTypeFrame)
        self.hashTypeCombo.setGeometry(QtCore.QRect(10, 40, 161, 31))
        self.hashTypeCombo.setObjectName("hashTypeCombo")
        self.detectHashBtn = QtWidgets.QPushButton(self.hashTypeFrame)
        self.detectHashBtn.setGeometry(QtCore.QRect(10, 100, 161, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.detectHashBtn.setFont(font)
        self.detectHashBtn.setObjectName("detectHashBtn")
        self.output = QtWidgets.QTextBrowser(self.attackGroup)
        self.output.setGeometry(QtCore.QRect(120, 230, 861, 321))
        self.output.setObjectName("output")
        self.passwordFileBtn = QtWidgets.QPushButton(self.attackGroup)
        self.passwordFileBtn.setGeometry(QtCore.QRect(890, 30, 91, 31))
        self.passwordFileBtn.setObjectName("passwordFileBtn")
        self.pauseBtn = QtWidgets.QPushButton(self.attackGroup)
        self.pauseBtn.setGeometry(QtCore.QRect(10, 440, 101, 31))
        self.pauseBtn.setObjectName("pauseBtn")
        self.resumeBtn = QtWidgets.QPushButton(self.attackGroup)
        self.resumeBtn.setGeometry(QtCore.QRect(10, 480, 101, 31))
        self.resumeBtn.setObjectName("resumeBtn")
        self.saveBtn = QtWidgets.QPushButton(self.attackGroup)
        self.saveBtn.setGeometry(QtCore.QRect(10, 520, 101, 31))
        self.saveBtn.setObjectName("saveBtn")
        self.stopBtn = QtWidgets.QPushButton(self.attackGroup)
        self.stopBtn.setGeometry(QtCore.QRect(10, 400, 101, 31))
        self.stopBtn.setObjectName("stopBtn")
        self.newAttackGroup = QtWidgets.QGroupBox(self.centralwidget)
        self.newAttackGroup.setGeometry(QtCore.QRect(10, 580, 621, 71))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Highlight, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 120, 215))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Highlight, brush)
        self.newAttackGroup.setPalette(palette)
        font = QtGui.QFont()
        font.setPointSize(16)
        self.newAttackGroup.setFont(font)
        self.newAttackGroup.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.newAttackGroup.setObjectName("newAttackGroup")
        self.newAttackNameLbl = QtWidgets.QLabel(self.newAttackGroup)
        self.newAttackNameLbl.setGeometry(QtCore.QRect(10, 30, 81, 21))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.newAttackNameLbl.setFont(font)
        self.newAttackNameLbl.setObjectName("newAttackNameLbl")
        self.newAttackNameTxt = QtWidgets.QTextEdit(self.newAttackGroup)
        self.newAttackNameTxt.setGeometry(QtCore.QRect(80, 30, 311, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.newAttackNameTxt.setFont(font)
        self.newAttackNameTxt.setObjectName("newAttackNameTxt")
        self.createNewAttackBtn = QtWidgets.QPushButton(self.newAttackGroup)
        self.createNewAttackBtn.setGeometry(QtCore.QRect(510, 30, 101, 31))
        self.createNewAttackBtn.setObjectName("createNewAttackBtn")
        self.loadNewAttackBtn = QtWidgets.QPushButton(self.newAttackGroup)
        self.loadNewAttackBtn.setGeometry(QtCore.QRect(400, 30, 101, 31))
        self.loadNewAttackBtn.setObjectName("loadNewAttackBtn")
        self.helpBtn = QtWidgets.QPushButton(self.centralwidget)
        self.helpBtn.setGeometry(QtCore.QRect(930, 600, 51, 41))
        font = QtGui.QFont()
        font.setPointSize(18)
        self.helpBtn.setFont(font)
        self.helpBtn.setObjectName("helpBtn")
        App.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(App)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1012, 22))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuAttack = QtWidgets.QMenu(self.menubar)
        self.menuAttack.setObjectName("menuAttack")
        self.menuAbout = QtWidgets.QMenu(self.menubar)
        self.menuAbout.setObjectName("menuAbout")
        App.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(App)
        self.statusbar.setObjectName("statusbar")
        App.setStatusBar(self.statusbar)
        self.actionNew = QtGui.QAction(App)
        self.actionNew.setObjectName("actionNew")
        self.actionOpen = QtGui.QAction(App)
        self.actionOpen.setObjectName("actionOpen")
        self.actionSave = QtGui.QAction(App)
        self.actionSave.setObjectName("actionSave")
        self.actionCopy = QtGui.QAction(App)
        self.actionCopy.setObjectName("actionCopy")
        self.actionpaste = QtGui.QAction(App)
        self.actionpaste.setObjectName("actionpaste")
        self.actionLoad = QtGui.QAction(App)
        self.actionLoad.setObjectName("actionLoad")
        self.actionSave_2 = QtGui.QAction(App)
        self.actionSave_2.setObjectName("actionSave_2")
        self.menuFile.addAction(self.actionLoad)
        self.menuFile.addAction(self.actionSave_2)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuAttack.menuAction())
        self.menubar.addAction(self.menuAbout.menuAction())

        #Initialize combo boxes
        self._initComboBox()

        #Creating all button click events
        self.crackBtn.clicked.connect(self._crack)
        self.attackOptionsBtn.clicked.connect(self._options)
        self.detectHashBtn.clicked.connect(self._detect)
        self.createNewAttackBtn.clicked.connect(self._createNewAttack)
        self.loadNewAttackBtn.clicked.connect(self._load)
        self.browseBtn.clicked.connect(self._browseWordlist)
        self.passwordFileBtn.clicked.connect(self._browsePasswordFile)
        self.pauseBtn.clicked.connect(self._pause)
        self.resumeBtn.clicked.connect(self._resume)
        self.saveBtn.clicked.connect(self._save)
        self.stopBtn.clicked.connect(self._stop)
        self.helpBtn.clicked.connect(self._help)

        #On a combo box change, call _alterFrame
        self.attackTypeCombo.currentIndexChanged.connect(self._alterFrame) 

        self.retranslateUi(App)
        QtCore.QMetaObject.connectSlotsByName(App)

    def retranslateUi(self, App):
        _translate = QtCore.QCoreApplication.translate
        App.setWindowTitle(_translate("App", "MainWindow"))
        self.attackGroup.setTitle(_translate("App", "Hash Attack 1"))
        self.hashValueLbl.setText(_translate("App", "Hash"))
        self.hashInputTxt.setToolTip(_translate("App", "Hash value you want to crack."))
        self.crackBtn.setToolTip(_translate("App", "Start attack."))
        self.crackBtn.setText(_translate("App", "Crack!"))
        self.deviceLbl.setText(_translate("App", "Device"))
        self.cpu_enabled.setToolTip(_translate("App", "Use multi-processing to crack the password"))
        self.cpu_enabled.setText(_translate("App", "CPU"))
        self.charsetLbl.setText(_translate("App", "Charset"))
        self.charsetAll.setText(_translate("App", "All"))
        self.charsetLower.setToolTip(_translate("App", "abcdefghijklmnopqrstuvwxyz"))
        self.charsetLower.setText(_translate("App", "Lower Alpha (a-z)"))
        self.charsetUpper.setToolTip(_translate("App", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
        self.charsetUpper.setText(_translate("App", "Upper Alpha (A-Z)"))
        self.charsetNumbers.setToolTip(_translate("App", "1234567890"))
        self.charsetNumbers.setText(_translate("App", "Numbers (0-9)"))
        self.charsetSymbols.setToolTip(_translate("App", "!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ "))
        self.charsetSymbols.setText(_translate("App", "Symbols (!,@)"))
        self.wordlistLbl.setText(_translate("App", "Word List"))
        self.wordlistTxt.setToolTip(_translate("App", "Dictionary of breached passwords or common words for selected attacks"))
        self.browseBtn.setToolTip(_translate("App", "Browse file system for wordlist"))
        self.browseBtn.setText(_translate("App", "Browse"))
        self.wordlistFilenameLbl.setText(_translate("App", ":"))
        self.attackTypeLbl.setText(_translate("App", "Attack Type"))
        self.attackTypeCombo.setToolTip(_translate("App", "Select the method to crack the hash value."))
        self.attackOptionsBtn.setToolTip(_translate("App", "Options for each attack method"))
        self.attackOptionsBtn.setText(_translate("App", "Attack Options"))
        self.hashTypeLbl.setText(_translate("App", "Hash Type"))
        self.hashTypeCombo.setToolTip(_translate("App", "The hashing algorithm of the provided hash value."))
        self.detectHashBtn.setToolTip(_translate("App", "Auto detect the hashing algorithm for a hash value."))
        self.detectHashBtn.setText(_translate("App", "Detect"))
        self.passwordFileBtn.setToolTip(_translate("App", "Upload multiple passwords in a file to crack."))
        self.passwordFileBtn.setText(_translate("App", "PWD File"))
        self.pauseBtn.setToolTip(_translate("App", "Pause an attack"))
        self.pauseBtn.setText(_translate("App", "Pause"))
        self.resumeBtn.setToolTip(_translate("App", "Resume attack"))
        self.resumeBtn.setText(_translate("App", "Resume"))
        self.saveBtn.setToolTip(_translate("App", "Save Attack to txt file"))
        self.saveBtn.setText(_translate("App", "Save"))
        self.stopBtn.setToolTip(_translate("App", "Stop attack"))
        self.stopBtn.setText(_translate("App", "Stop"))
        self.newAttackGroup.setTitle(_translate("App", "Create New Attack"))
        self.newAttackNameLbl.setText(_translate("App", "Name: "))
        self.newAttackNameTxt.setToolTip(_translate("App", "Name of a new attack"))
        self.createNewAttackBtn.setToolTip(_translate("App", "Create new attack."))
        self.createNewAttackBtn.setText(_translate("App", "Create"))
        self.loadNewAttackBtn.setToolTip(_translate("App", "Load previous attack"))
        self.loadNewAttackBtn.setText(_translate("App", "Load"))
        self.helpBtn.setText(_translate("App", "?"))
        self.menuFile.setTitle(_translate("App", "File"))
        self.menuAttack.setTitle(_translate("App", "Attack"))
        self.menuAbout.setTitle(_translate("App", "About"))
        self.actionNew.setText(_translate("App", "New"))
        self.actionNew.setStatusTip(_translate("App", "Creates a new file"))
        self.actionNew.setShortcut(_translate("App", "Ctrl+N"))
        self.actionOpen.setText(_translate("App", "Open"))
        self.actionSave.setText(_translate("App", "Save"))
        self.actionSave.setStatusTip(_translate("App", "Saves a file"))
        self.actionCopy.setText(_translate("App", "Copy"))
        self.actionCopy.setStatusTip(_translate("App", "Copy a file"))
        self.actionCopy.setShortcut(_translate("App", "Ctrl+C"))
        self.actionpaste.setText(_translate("App", "paste"))
        self.actionpaste.setStatusTip(_translate("App", "Paste a file"))
        self.actionpaste.setShortcut(_translate("App", "Ctrl+S"))
        self.actionLoad.setText(_translate("App", "Load"))
        self.actionSave_2.setText(_translate("App", "Save"))
        
    """
    Name: _alterFrame
    Description: Will disable frames depending on the attack type selected
    Parameters: self
    returns: none
    """
    def _alterFrame(self):
        #Gets currently selected attack type
        attack_selection = self.attackTypeCombo.currentText()

        if(attack_selection == "Brute Force"):
            self.wordlistFrame.setEnabled(False) 
            self.charsetFrame.setEnabled(True)
            self.charsetLower.setEnabled(True)
            self.charsetUpper.setEnabled(True)
            self.wordlistLbl.setText("WordList") 
            
        elif(attack_selection == "Dictionary"):
            self.wordlistFrame.setEnabled(True)
            self.charsetFrame.setEnabled(False)
            self.wordlistLbl.setText("Wordlist") 

        elif(attack_selection == "Hybrid"):
            self.wordlistFrame.setEnabled(True) 
            self.charsetFrame.setEnabled(False)
            self.wordlistLbl.setText("Wordlist") 
        
        elif(attack_selection == "Rule-Based"):
            self.wordlistFrame.setEnabled(True) 
            self.charsetFrame.setEnabled(False)
            self.charsetLower.setEnabled(True)
            self.charsetUpper.setEnabled(True)
            self.wordlistLbl.setText("Wordlist") 
        
        elif(attack_selection == "Rainbow Table"):
            self.wordlistFrame.setEnabled(True) 
            self.charsetFrame.setEnabled(False)
            self.attackOptionsBtn.setEnabled(False)
            self.wordlistLbl.setText("Rainbow table") 
            
        elif(attack_selection == "Markov Chain"):
            self.wordlistFrame.setEnabled(False) 
            self.charsetFrame.setEnabled(False)

    """
    Name: _check_parameters
    Description: Will check if parameters on GUI are filled in
    Parameters: self
    returns: check: Boolean tuple
    """
    def _check_parameters(self):
        check = [True, True, True] #assume user has filled in the form
        #Check if user filled in values 
        if(self.attack_options.hash_value == ""):
            self.output.append("-= No Hash Value Entered =-")
            check[0] = False
        if(self.attack_options.hash_type == ""):
            self.output.append("-= No Hash Type Selected =-")
            check[1] = False
        if(self.attack_options.attack_type == ""):
            self.output.append("-= No Attack Type Selected =-")
            check[2] = False
        return check

    """
    Name: __getHashValue__
    Description: Will return the plain text hash value from input box
    Parameters: self
    returns: self.hashInputTxt: String
    """
    def __getHashValue__(self):
        return self.hashInputTxt.toPlainText()

    """
    Name: _initComboBox
    Description: Will initialize all combo boxs on the application
    Parameters: self
    returns: none
    """
    def _initComboBox(self):
        self.hashTypeCombo.setPlaceholderText("Select Hash")
        self.hashTypeCombo.addItems(self.hash_type_content)
        self.attackTypeCombo.setPlaceholderText("Select Attack")
        self.attackTypeCombo.addItems(self.attack_type_content)

    """
    Name: _browsePasswordFile
    Description: Will load a password file with multiple hash values
    Parameters: self
    returns: none
    """
    def _browsePasswordFile(self):
        print("-Load Password File-")
        #Open file dialog box
        hash_file = QtWidgets.QFileDialog.getOpenFileName(None, 'Open password file', 'C:\\', '*.txt')
        #set text edit to wordlist location
        self.hashInputTxt.insertPlainText(hash_file[0])
        self.hash_file_location = hash_file[0]
        print(self.hash_file_location)
        
    """
    Name: _browseWordlist
    Description: Will load a new attack from a text file
    Parameters: self
    returns: none
    """
    def _browseWordlist(self):
        print("-Browse Wordlist-")
        self.wordlist_location = ""
        #Open file dialog box
        wordlist_location = QtWidgets.QFileDialog.getOpenFileName(None, 'Open Wordlist', 'C:\\', '*.txt')
        self.wordlistTxt.clear()
        #set text edit to wordlist location
        self.wordlistTxt.insertPlainText(wordlist_location[0])
        #split string to get filename
        file_name = wordlist_location[0].split("/")
        file_name = file_name[-1]
        #Set label to file name
       
        self.wordlistFilenameLbl.setText(file_name)
        self.wordlist_location = wordlist_location[0]

    """
    Name: _process_charset
    Description: Will process the character set for the attack_options
    Parameters: self
    returns: character_set:String
    """
    def _process_charset(self):
        character_set = ""
        if(self.attack_options.charsetAll):
            character_set = self.numeric + self.lower_alpha + self.upper_alpha + self.symbols
        if(self.attack_options.charsetLower):
            character_set = character_set + self.lower_alpha
        if(self.attack_options.charsetUpper):
            character_set = character_set + self.upper_alpha
        if(self.attack_options.charsetNumbers):
            character_set = character_set + self.numeric
        if(self.attack_options.charsetSymbols):
            character_set = character_set + self.symbols
        # elif: 
        #     self.output.append("Please Select at least 1 character set to start a Brute Force attack")

        return character_set

    """
    Name: _crack
    Description: Will start a crack when user hash is provided
    Parameters: self
    returns: none
    """
    def _crack(self):
        print("-Crack-")
        #Initializes Attack options with a name
        self.attack_options = AttackOptions("Attack1")

        #Initialize vairbales in AttackOptions with values from GUI
        self.attack_options.hash_value = self.__getHashValue__()
        self.attack_options.hash_type = str(self.hashTypeCombo.currentText())
        self.attack_options.attack_type = str(self.attackTypeCombo.currentText())
        self.attack_options.wordlist_location = self.wordlistTxt.toPlainText()
        self.attack_options.hash_file_location = self.hash_file_location
        self.attack_options.charsetAll = self.charsetAll.isChecked()
        self.attack_options.charsetLower = self.charsetLower.isChecked()
        self.attack_options.charsetUpper = self.charsetUpper.isChecked()
        self.attack_options.charsetNumbers = self.charsetNumbers.isChecked()
        self.attack_options.charsetSymbols = self.charsetSymbols.isChecked()
        self.attack_options.cpu = self.cpu_enabled.isChecked()
        self.attack_options.core_count = self.options.attack_options.core_count
        self.attack_options.max_brute_force = self.options.attack_options.max_brute_force
        self.attack_options.min_brute_force = self.options.attack_options.min_brute_force

        
        parameter_check = self._check_parameters()
        if(parameter_check == [True, True, True]):
            if(self.attack_options.attack_type == "Brute Force"):
                charset = self._process_charset()
                self.output.append("==========================================================")                
                self.output.append(" Starting Attack ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Wordlist: {self.attack_options.wordlist_location}")
                self.output.append(f"\t- Charset: '{charset}'")
                self.output.append(f"\t- Processes: {self.attack_options.core_count}")
                self.output.append(f"\t- Min len: {self.attack_options.min_brute_force}")
                self.output.append(f"\t- Max len: {self.attack_options.max_brute_force}")

                #Creates another thread for the attack to run on to prevent application freezing
                pool = QThreadPool.globalInstance()
                self.worker = BruteForceWorker(self.attack_options, charset, self.output)
                pool.start(self.worker)
            
            if(self.attack_options.attack_type == "Dictionary"):
                self.output.append("====================================================")                
                self.output.append(f" -= Starting {self.attack_options.name} =- ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Wordlist: {self.attack_options.wordlist_location}")
                
                self.pool = QThreadPool.globalInstance()
                self.worker = DictionaryWorker(self.attack_options, self.output)
                self.pool.start(self.worker)

            if(self.attack_options.attack_type == "Hybrid"):
                self.output.append("====================================================")                
                self.output.append(" Starting Attack ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Wordlist: {self.attack_options.wordlist_location}")
                self.output.append(f"\r- Processes: {self.attack_options.core_count}")
                
                pool = QThreadPool.globalInstance()
                self.worker = HybridWorker(self.attack_options, self.output)
                pool.start(self.worker)

            if(self.attack_options.attack_type == "Rule-Based"):
                self.output.append("====================================================")                
                self.output.append(" Starting Attack ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Ruleset: {self.attack_options.wordlist_location}")
                self.output.append(f"\t- Processes: {self.attack_options.core_count}")
            
                pool = QThreadPool.globalInstance()
                self.worker = RuleBasedWorker(self.attack_options, self.output)
                pool.start(self.worker)

            if(self.attack_options.attack_type == "Rainbow Table"):
                self.output.append("====================================================")                
                self.output.append(" Starting Attack ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Rainbowtable: {self.attack_options.wordlist_location}")
                self.output.append(f"\t- Processes: {self.attack_options.core_count}")

                rainbowtable=RainbowTableAttack(self.attack_options, self.output)
                rainbowtable.run()
                
        
            if(self.attack_options.attack_type == "Markov Chain"):
                self.output.append("====================================================")                
                self.output.append(" Starting Attack ")
                self.output.append(f"\t- Hash: {self.attack_options.hash_value}")
                self.output.append(f"\t- Type: {self.attack_options.hash_type}")
                self.output.append(f"\t- Attack: {self.attack_options.attack_type}")
                self.output.append(f"\t- Wordlist: {self.attack_options.wordlist_location}")
                self.output.append(f"\t- Processes: {self.attack_options.core_count}")

                pool = QThreadPool.globalInstance()
                self.worker = MarkovWorker(self.attack_options, self.output)
                pool.start(self.worker)
                

        else:
            print("Cannot start attack")

    """
    Name: _pause
    Description: Will pause a current attack
    Parameters: self
    returns: none
    """
    def _pause(self):
        print("- Pause Attack -")
        self.worker.pause_process()
        print("- Starting again -")

    """
    Name: _resume
    Description: Will resume the current attack
    Parameters: self
    returns: none
    """
    def _resume(self):
        print("-Resume Attack-")
        self.worker.resume_process()
        print("Attack Resumed")
    
    """
    Name: _stop
    Description: Will stop a the current attack
    Parameters: self
    returns: none
    """
    def _stop(self):
        print("-Stop Attack-")
        try:
            self.worker.stop_process()
        except AttributeError as e:
            print(e) 
            self.output.append(" -= Cannot stop that hasn't started =- ")
            return

    """
    Name: recurse_filename
    Description: Will recursivly change the filename if the same one already exists
    Parameters: self, num:Integer, password:String
    returns: none
    """
    def _recurse_filename(self, num, location):
        try:
            new_filename = f"AppData/attack{num}.txt"
            self._save_file(location)

        except FileExistsError:
            self._recurse_filename(num+1, location)


    """
    Name: _save_file
    Description: Will create the file and write data to file
    Parameters: self, location: String - file location
    returns: none
    """
    def _save_file(self, location):
        num = 1
        with open(location, "x") as file:
            try:
                file.write(f"name={self.temp_name}\n")
                file.write(f"hash_value={self.attack_options.hash_value}\n")
                file.write(f"hash_type={self.attack_options.hash_type}\n")
                file.write(f"attack_type={self.attack_options.attack_type}\n")
                file.write(f"wordlist_location={self.attack_options.wordlist_location}\n")
                file.write(f"hash_file_location={self.attack_options.hash_file_location}\n")
                file.write(f"charsetLower={self.attack_options.charsetLower}\n")
                file.write(f"charsetUpper={self.attack_options.charsetUpper}\n")
                file.write(f"charsetNumbers={self.attack_options.charsetNumbers}\n")
                file.write(f"charsetSymbols={self.attack_options.charsetSymbols}\n")
                file.write(f"wordlistLbl={self.temp_wordlistlbl}\n")
                file.write(f"core_count={self.attack_options.core_count}\n")
                file.write(f"pass_phrase_len={self.attack_options.pass_phrase_len}\n")
                file.write(f"max_brute_force={self.attack_options.max_brute_force}\n")
                file.write(f"output=\n{self.temp_output}")

                self.output.append("-= File Saved Successfully =-")
            except AttributeError:
                self.output.append(" -= You cannot save without starting an attack =- ")
            except FileExistsError:
                self._recurse_filename(num, location)
        
    """
    Name: _save
    Description: Will save an attack to a text file
    Parameters: self
    returns: none
    """
    def _save(self):
        print("-Save Attack-")
        try:
            self.temp_wordlistlbl = self.wordlistFilenameLbl.text()
            self.temp_output = self.output.toPlainText()
            self.temp_name = self.attack.objectName()

            self.save_location = QFileDialog.getSaveFileName(None,'Save File')

            self._save_file(f"{self.save_location[0]}.txt")
        except AttributeError:
            self.output.append(" -= Cannot save an attack that has not started =- ")


    """
    Name: _load
    Description: Will load a new attack from a text file
    Parameters: self
    returns: none
    """
    def _load(self):
        print("-Load Attack-")
        attack_location = QtWidgets.QFileDialog.getOpenFileName(None, 'Open Previous attack', 'C:\\', '*.txt')
        self.attack_options = None
        data = list()
        
        with open(attack_location[0], encoding="latin-1") as file:
            for idx, data in enumerate(file):
                if(idx < 15):
                    data = data.split("=")
                    data[1] = data[1].replace("\n", "")
                    #Handles name in file
                    if(idx == 0):
                        self.attack_options = AttackOptions(data[1])
                    elif(idx == 1):
                        self.attack_options.hash_value = data[1] 
                    elif(idx == 2):
                        self.attack_options.hash_type = data[1]
                    elif(idx == 3):
                        self.attack_options.attack_type = data[1]
                    elif(idx == 4):
                        self.attack_options.wordlist_location = data[1]
                    elif(idx == 5):
                        self.attack_options.hash_file_location = data[1]
                    elif(idx == 6):
                        self.attack_options.charsetLower = bool(data[1])
                    elif(idx == 7):
                        self.attack_options.charsetUpper = bool(data[1])
                    elif(idx == 8):
                        self.attack_options.charsetNumbers = bool(data[1])
                    elif(idx == 9):
                        self.attack_options.charsetSymbols = bool(data[1])
                    elif(idx == 10):
                        self.wordlistLbl.setText(data[1])
                    elif(idx == 11):
                        self.attack_options.core_count = bool(data[1])
                    elif(idx == 12):
                        self.attack_options.pass_phrase_len = bool(data[1])
                    elif(idx == 13):
                        self.attack_options.max_brute_force = data[1]
                else:
                    self.output.append(data)

        self.hashInputTxt.setText(self.attack_options.hash_value)
        self.hashTypeCombo.setCurrentText(self.attack_options.hash_type)
        self.attackTypeCombo.setCurrentText(self.attack_options.attack_type)
        self.wordlistTxt.setPlainText(self.attack_options.wordlist_location)
        self.charsetAll.setChecked(self.attack_options.charsetAll)
        self.charsetLower.setChecked(self.attack_options.charsetLower)
        self.charsetUpper.setChecked(self.attack_options.charsetUpper)
        self.charsetNumbers.setChecked(self.attack_options.charsetNumbers)
        self.charsetSymbols.setChecked(self.attack_options.charsetSymbols)
        self.cpu_enabled.setChecked(self.attack_options.cpu)

    """
    Name: _options
    Description: will open up the application options
    Parameters: self
    returns: none
    """
    def _options(self):
        print("-Options-")  
        self.window = QtWidgets.QMainWindow()
        self.options.setupUi(self.window)
        self.window.show()

    """
    Name: _help
    Description: will open up the application help
    Parameters: self
    returns: none
    """
    def _help(self):
        print("-Help-")
        self.window = QtWidgets.QMainWindow()
        self.help = Ui_AlgorithmDocs()
        self.help.setupUi(self.window)
        self.window.show()

    """
    Name: _detect
    Description: Will try and detect hash from input field
    Parameters: self
    Returns: none
    """
    def _detect(self):
        print("-Detect Hash-")
        self.hash_value = self.__getHashValue__()

    """
    Name: _createNewAttack
    Description: Will create a new attack from create attack page
    Parameters: self
    returns: none
    """
    def _createNewAttack(self):
        print("-Create new Attack-")
        self.hashInputTxt.clear()
        self.hashTypeCombo.clear()
        self.attackTypeCombo.clear()
        self.wordlistTxt.clear()
        self.charsetAll.setChecked(False)
        self.charsetLower.setChecked(False)
        self.charsetUpper.setChecked(False)
        self.charsetNumbers.setChecked(False)
        self.charsetSymbols.setChecked(False)
        self.cpu_enabled.setChecked(False)
        self.output.clear()
        new_attack_name = self.newAttackNameTxt.toPlainText()
        self.attackGroup.setObjectName(new_attack_name)
        self.attack_options = AttackOptions(new_attack_name)



if __name__ == "__main__":  
    import sys
    app = QtWidgets.QApplication(sys.argv)
    App = QtWidgets.QMainWindow()
    app.setWindowIcon(QtGui.QIcon('img/logo.png'))
    ui = Ui_App()
    ui.setupUi(App)
    App.show()

    app.exec()

